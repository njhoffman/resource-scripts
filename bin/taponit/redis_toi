#!/usr/bin/env node

// TODO: Make this it's own global node_modules

const async = require('async');
const _ = require('lodash');
const sshTunnel = require('tunnel-ssh');
const redis = require('redis');
const columnify = require('columnify');
const fs = require('fs');

const privateKey = fs.readFileSync('/home/vagrant/.ssh/jumpOnIt.pem')

const host = '52.205.254.219';
const dstHost =  'taponit.ys76rf.ng.0001.use1.cache.amazonaws.com';

var config = {
	username:'ec2-user',
	host,
	dstHost,
	dstPort: 6379,
  localPort: 4000,
  privateKey
};


const getMessagesProcessing = (client, type, data, done) => {
  client.lrange(`joi:outgoing:${type}_processing`, 0, -1, (err, replies) => {
    replies.forEach(reply => {
      data.processing[type].push(reply);
    });
    done(err, data);
  });
};

const lookupMessageData = (client, type) => (key, done) => {
  client.hgetall(`joi:outgoing:${type}:messageData:${key}`, done);
};


const processMessages = (messages) => {
  return _.map(messages,
    (msg) => {
      const dt = new Date(msg.created.replace(/"/g,''));
      const mon = _.padStart(dt.getMonth() + 1, 2, 0);
      const d = _.padStart(dt.getDate(), 2, 0);
      const h = _.padStart(dt.getHours(), 2, 0);
      const min = _.padStart(dt.getMinutes(), 2, 0);
      const s = _.padStart(dt.getSeconds(), 2, 0);
      return {
        'Date': `${mon}-${d} ${h}:${min}:${s}`,
        'TransactionGUID': msg.transactionGUID,
        'Number': msg.destination,
        'Subscriber': msg.subscriberID,
        'Market': msg.marketID,
        'Campaign': msg.campaignID,
        'Content': msg.body ? msg.body : msg.messageText,
        // 'URL Code': msg.urlCode
      }
    });
};

const printColumns = (data) => {
  const columns = columnify(data, {
    truncate: true,
    minWidth: 20,
    align: 'center',
    config: {
      'Date': { },
      'Market': { minWidth: 10 },
      'Campaign': { minWidth: 10 },
      'Subscriber': { minWidth: 10 },
      'Content' : { maxWidth: 50 },
      'URL Code': { },
      'Number': { },
      'TransactionGUID': { },
    }
  });
  console.log('\n', columns);
};

const tunnel = sshTunnel(config, (err, server) => {
  if (err) {
    console.error('SSH Connection Error', err);
  } else {
    console.log(`Connected to host ${config.host}`);
    console.log(`Tunneling local port ${config.localPort} to ${config.dstHost}:${config.dstPort}`);
    console.log('Connecting to redis server ...');

    const client = redis.createClient({ port: 4000 });

    client.on('connect', () => console.log('Redis connected'));
    client.on('ready', () => console.log('Redis ready'));
    client.on('end', () => console.log('Redis end'));
    client.on('error', (err) => console.error('Redis Client Error', err));

    client.on('monitor', (time, args, raw_reply) => {
      console.log(time + ': ' + args);
    });

    const data = { processing: { mms: [], sms: [] } };
    async.waterfall([
      (done) => getMessagesProcessing(client, 'sms', data, done),
      (data, done) => getMessagesProcessing(client, 'mms', data, done),
      (data, done) => {
        async.map(data.processing.sms, lookupMessageData(client, 'sms'), (err, results) => {
          data.processing.sms = results;
          done(err, data);
        });
      },
      (data, done) => {
        async.map(data.processing.mms, lookupMessageData(client, 'mms'), (err, results) => {
          data.processing.mms = results;
          done(err, data);
        });
      },
    ], (err, res) => {

      // campaignURL, campaignID, urlCode, reated, source, subscriberID, subject, messageText, body, auth, attachments
      // const columns = columnify(data.processing.sms, { columns: ['transactionGUID', 'destination', 'subscriberID'] });

      console.log('\n  => MMS Messages in Processing');
      printColumns(processMessages(data.processing.mms));
      console.log('\n  => SMS Messages in Processing');
      printColumns(processMessages(data.processing.sms));

      process.exit(0);
    });
  }
});

tunnel.on('error', (err) => {
  console.error('SSH-Tunnel Error', err);
});
